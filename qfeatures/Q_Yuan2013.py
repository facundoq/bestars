# -*- coding: utf-8 -*-
"""Clasificacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19LSp23dP-lK8UWveeieYqCnVLFa6mCmQ
"""

import numpy as np

import pandas as pd

df0= pd.read_csv('Mohr-Smith_2017_Completa_VPHAS-2MASS-ALLWISE_OK.csv')
#%%
"""
Elegimos las columnas del archivo con las que vamos a trabajar

-----IMPORTANTE------

Las columnas de las magnitudes deben estar acomodadas del azul hacia el rojo
y ser el ultimo bloque de columnas
"""
column_names=['EM', 'SUB', 'LUM', 'umag', 'gmag', 'rmag', 'Hamag', 'imag', 
              'Jmag', 'Hmag', 'Kmag', 'W1mag', 'W2mag']

#%%
"""
Tomo los valores de r_lambda = A_lambda/E(B-V) del trabajo de 
Yuan et al. (2013)
(Tabla 2 columna 1)

Defino el sistema fotometrico de cada filtro

Para eso armo un diccionario donde la llave es el nombre de la columna 
del dataframe df0
y la defino con una lista con los siguientes elementos:
    
[sistema fotometrico, nombre del filtro, lambda eff (en angstroms), coeficiente r]

El coeficiente r es el que se usa para calcular el Q.
"""



#%%
# Armo un dataframe solo con las columnas que me interesan

df= df0[column_names]

"""Elimino las filas que tienen valores NaN"""
df= df.dropna(subset=column_names)

"""
Armo la clasificacion:

        Estrellas con emision      -> EM = 1
        Estrellas Subluminosas     -> SUB = 1
        Estrellas Sobreluminosas   -> LUM = 1
"""

mask_EM= (df['EM'] == 1)
mask_SUB= (df['SUB'] == 1)
mask_LUM= (df['LUM'] == 1)

mask_OB_nor= (~mask_EM & ~mask_SUB & ~mask_LUM)
mask_OB_EM= (mask_EM & ~mask_SUB & ~mask_LUM)
mask_OB_SUB= (~mask_EM & mask_SUB & ~mask_LUM)
mask_OB_LUM= (~mask_EM & ~mask_SUB & mask_LUM)

df['Target']=np.nan
df['Target'][mask_OB_nor]=111
df['Target'][mask_OB_EM]=222
df['Target'][mask_OB_SUB]=333
df['Target'][mask_OB_LUM]=444
df= df.dropna(subset=column_names)
df= df.dropna(subset=['Target'])

dic= {'111': 'OB', '222': 'EM', '333': 'SUB', '444': 'LUM'}
#%%

